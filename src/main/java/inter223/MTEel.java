package inter223;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Charsets;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.TreeMultimap;
import com.google.common.io.Files;

// I looked up quite a bit of stuff, especially on the java docs for java.util.concurrent
// and guava for the nice thread-safe multimap
// the multimap is write-thread safe, but should synchronize on reading (but I don't read in more than 1 thread)
public class MTEel {

	static List<String> wordsToProcess = new ArrayList<>();
	static Multimap<Integer, String> problemCountToOffendingWord = Multimaps.synchronizedMultimap(TreeMultimap.<Integer, String>create()); 
	
	public void prefillWordsToProcess() {
		try (BufferedReader br = Files.newReader(new File("enable1.txt"), Charsets.UTF_8)) {
			String word;
			while ((word = br.readLine()) != null) {
				wordsToProcess.add(word);
			}
			
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}
	}
	
	class EelRunner implements Runnable {
		final Eel e;
		final String offensiveWord;
		List<String> problemWords = new ArrayList<>();
		public EelRunner(String offensiveWord) {
			this.offensiveWord = offensiveWord;
			e = new Eel(offensiveWord);
		}
		
		@Override
		public void run() {
			for(String s: wordsToProcess) {
				if (e.isOffensive(s)) {
					problemWords.add(s);
				}
			}
			problemCountToOffendingWord.put(problemWords.size(), offensiveWord);
		}	
	}
	
	public void doit() {
		long startTime = System.nanoTime();
		prefillWordsToProcess();
		long afterPreFill = System.nanoTime();
		final ExecutorService threadPool; 
		
		// interesting, on i5-4670K (2 CPU x 2 Core), performance is halved when going to 2, and 
		// no change when going past 4 (well, I guess that's obvious)
		threadPool = Executors.newFixedThreadPool(4);
		
		// uh oh..
		// current preformance: 
		// 26^0  1 word       : 110ms (31ms to read enable1.txt)
		// 26^1  26 words     : 290ms (31ms to read enable1.txt)
		// 26^2  676 words    : 1977ms (32ms to read enable1.txt)
		// 26^3  17576 words  : 38999ms (31ms to read enable1.txt)
		// 26^4  456976 words : ? (estimated around 17 minutes)
		// 26^5  11881376 words : ? (estimated around 7 hours)
		
		// change how many words are generated by playing with the limit of each for loop
		char[] letters = new char[5];
		for(char c1 = 'a'; c1 <= 'z'; c1++) {
			for(char c2 = 'a'; c2 <= 'a'; c2++) {
				for(char c3 = 'a'; c3 <= 'a'; c3++) {
					for(char c4 = 'a'; c4 <= 'a'; c4++) {
						for(char c5 = 'a'; c5 <= 'a'; c5++) {
							letters[0] = c1; letters[1] = c2; letters[2] = c3; letters[3] = c4; letters[4] = c5;
							String attempt = String.valueOf(letters).trim();
							threadPool.submit(new EelRunner(attempt));
						}						
					}					
				}				
			}			
		}
		threadPool.submit(new EelRunner("esses"));
		threadPool.submit(new EelRunner("iiiii"));
		threadPool.submit(new EelRunner("tssss"));
		threadPool.shutdown();	
		
		try {
			threadPool.awaitTermination(100, TimeUnit.SECONDS);
		} catch (InterruptedException e) {
			System.out.println(e);
		}
		
		long endTime = System.nanoTime();
		long totalDuration = (endTime - startTime) / 1000000;
		long prefillDuration = (afterPreFill - startTime) / 1000000;

		int numberOfWordsTested = problemCountToOffendingWord.size();
		
		System.out.println("Amish's concurrent performance for " + numberOfWordsTested + " words: " + 
				totalDuration + "ms out of which " + prefillDuration + "ms was for reading the file");

		// Display the top 10 problem counts 
		List<Integer> countOfOffensiveSecretWords = new ArrayList<>();
		countOfOffensiveSecretWords.addAll(problemCountToOffendingWord.keySet());
		Collections.sort(countOfOffensiveSecretWords, Collections.reverseOrder());
		int numberToDisplay = countOfOffensiveSecretWords.size() > 10 ? 10 : countOfOffensiveSecretWords.size();
		for(Integer i: countOfOffensiveSecretWords) {
			System.out.println(i + ": " + problemCountToOffendingWord.get(i));
			numberToDisplay--;
			if (numberToDisplay < 1) break;
		}		
	}
	
	public static void main(String[] args) {
		MTEel mtel = new MTEel();
		mtel.doit();		
	}
}
